{
  "Qwen/Qwen3-0.6B": [
    {
      "id": "s001061911.cpp",
      "original_c": "#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\n\nint main() {\n\tconst int len = 10;\n\tint arr[len];\n\n\tfor (int i = 0; i < len; i++)\n\t\tcin >> arr[i];\n\n\tfor (int i = 0; i < len; i++)\n\t\tfor (int j = 0; j < len; j++)\n\t\t\tif (arr[i] < arr[j])\n\t\t\t\tswap(arr[i], arr[j]);\n\n\tfor (int i = len - 1; len - 4 < i; i--)\n\t\tcout << arr[i] << endl;\n\n\treturn 0;\n}",
      "translated_code": "#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *arr, int len) {\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n\n    if (i < len && j < len && k < len) {\n        if (arr[i] < arr[j])\n            swap(arr[i], arr[j]);\n    }\n}\n\nint main() {\n    int len = 10;\n    int arr[len];\n    cudaMalloc(&arr, len * sizeof(int));\n    cudaMemcpy(arr, arr, len * sizeof(int), cudaMemcpyHostToDevice);\n    for (int i = 0; i < len; i++)\n        for (int j = 0; j < len; j++)\n            if (arr[i] < arr[j])\n                swap(arr[i], arr[j]);\n    cudaMemcpy(arr, arr, len * sizeof(int), cudaMemcpyDeviceToHost);\n    cudaFree(arr);\n    return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *arr, int len) {\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n\n    if (i < len && j < len && k < len) {\n        if (arr[i] < arr[j])\n            swap(arr[i], arr[j]);\n    }\n}\n\nint main() {\n    int len = 10;\n    int arr[len];\n    cudaMalloc(&arr, len * sizeof(int));\n    cudaMemcpy(arr, arr, len * sizeof(int), cudaMemcpyHostToDevice);\n    for (int i = 0; i < len; i++)\n        for (int j = 0; j < len; j++)\n            if (arr[i] < arr[j])\n                swap(arr[i], arr[j]);\n    cudaMemcpy(arr, arr, len * sizeof(int), cudaMemcpyDeviceToHost);\n    cudaFree(arr);\n    return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *arr, int len) {\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n\n    if (i < len && j < len && k < len) {\n        if (arr[i] < arr[j])\n            swap(arr[i], arr[j]);\n    }\n}\n\nint main() {\n    int len = 10;\n    int arr[len];\n    cudaMalloc(&arr, len * sizeof(int));\n    cudaMemcpy(arr, arr, len * sizeof(int), cudaMemcpyHostToDevice);\n    for (int i = 0; i < len; i++)\n        for (int j = 0; j < len; j++)\n            if (arr[i] < arr[j])\n                swap(arr[i], arr[j]);\n    cudaMemcpy(arr, arr, len * sizeof(int), cudaMemcpyDeviceToHost);\n    cudaFree(arr);\n    return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *arr, int len) {\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n\n    if (i < len && j < len && k < len) {\n        if (arr[i] < arr[j])\n            swap(arr[i], arr[j]);\n    }\n}\n\nint main() {\n    int len = 10;\n    int arr[len];\n    cudaMalloc(&arr, len * sizeof(int));\n    cudaMemcpy(arr, arr, len * sizeof(int), cudaMemcpyHostToDevice);\n    for (int i = 0; i < len; i++)\n        for (int j = 0; j < len; j++)\n            if (arr[i] < arr[j])\n                swap(arr[i], arr[j]);\n    cudaMemcpy(arr, arr, len * sizeof(int), cudaMemcpyDeviceToHost);\n    cudaFree(arr);\n    return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *arr, int len) {\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n\n    if (i < len && j < len && k < len) {\n        if (arr[i] < arr[j])\n            swap(arr[i], arr[j]);\n    }\n}\n\nint main() {\n    int len = 10;\n    int arr[len];\n    cudaMalloc(&arr, len * sizeof(int));\n    cudaMemcpy(arr, arr, len * sizeof(int), cudaMemcpyHostToDevice);\n    for (int i = 0; i < len; i++)\n        for (int j = 0; j < len; j++)\n            if (arr[i] < arr[j])\n                swap(arr[i], arr[j]);\n    cudaMemcpy(arr, arr, len * sizeof(int), cudaMemcpyDeviceToHost);\n    cudaFree(arr);\n    return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    },
    {
      "id": "s002114670.cpp",
      "original_c": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> hills;\n    \n    int n;\n    while (std::cin >> n) {\n        hills.push_back(n);\n    }\n    \n    std::sort(hills.begin(), hills.end(), std::greater<int>());\n    \n    for (int i = 0; i < 3; ++i) {\n        std::cout << hills[i] << std::endl;\n    }\n    \n    return 0;\n}",
      "translated_code": "#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_transpose(int *hills, int N) {\n    int idx = threadIdx.x;\n    int i = idx;\n    int j = N - 1 - idx;\n    \n    if (idx < N / 2) {\n        // swap hills[i] and hills[j]\n        int temp = hills[i];\n        hills[i] = hills[j];\n        hills[j] = temp;\n    } else {\n        // swap hills[i] and hills[j]\n        int temp = hills[i];\n        hills[i] = hills[j];\n        hills[j] = temp;\n    }\n}\n\nint main() {\n    int N = 1000;\n    int *hills = (int *)cudaMalloc(&hills, N * sizeof(int));\n    cudaMalloc(&hills, N * sizeof(int));\n    \n    // Read input from stdin\n    int n;\n    scanf(\"%d\", &n);\n    std::vector<int> hills_input(n);\n    for (int i = 0; i < n; i++) {\n        hills_input[i] = n;\n    }\n    \n    // Copy input to GPU\n    cudaMemcpy(hills, hills_input.data(), n * sizeof(int), cudaMemcpyHostToDevice);\n    \n    // Launch kernel\n   <<<1, N>>> = async_launch(odd_even_transpose, hills, N);\n    \n    // Free GPU memory\n    cudaFree(hills);\n    \n    // Print results\n    for (int i = 0; i < 3; ++i) {\n        printf(\"%d\\n\", hills[i]);\n    }\n    \n    return 0;\n}\n\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> hills;\n    \n    int n;\n    while (std::cin >> n) {\n        hills.push_back(n);\n    }\n    \n    std::sort(hills.begin(), hills.end(), std::greater<int>());\n    \n    for (int i = 0; i < 3; ++i) {\n        std::cout << hills[i] << std::endl;\n    }\n    \n    return 0;\n}\n\nCUDA code:\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_transpose(int *hills, int N) {\n    int idx = threadIdx.x;\n    int i = idx;\n    int j = N - 1 - idx;\n    \n    if (idx < N / 2) {\n        // swap hills[i] and hills[j]\n        int temp = hills[i];\n        hills[i] = hills[j];\n        hills[j] = temp;\n    } else {\n        // swap hills[i] and hills[j]\n        int temp = hills[i];\n        hills[i] = hills[j];\n        hills[j] = temp;\n    }\n}\n\nint main() {\n    int N = 1000;\n    int *hills = (int *)cudaMalloc(&hills, N * sizeof(int));\n    cudaMalloc(&hills, N * sizeof(int));\n    \n    // Read input from stdin\n    int n;\n    scanf(\"%d\", &n);\n    std::vector<int> hills_input(n);\n    for (int i = 0; i < n; i++) {\n        hills_input[i] = n;\n    }\n    \n    // Copy input to GPU\n    cudaMemcpy(hills, hills_input.data(), n * sizeof(int), cudaMemcpyHostToDevice);\n    \n    // Launch kernel\n   <<<1, N>>> = async_launch(odd_even_transpose, hills, N);\n    \n    // Free GPU memory\n    cudaFree(hills);\n    \n    // Print results\n    for (int i = 0; i < 3; ++i) {\n        printf(\"%d\\n\", hills[i]);\n    }\n    \n    return 0;\n}\n\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> hills;\n    \n    int n;\n    while (std::cin >> n) {\n        hills.push_back(n);\n    }\n    \n    std::sort(hills.begin(), hills.end(), std::greater<int>());\n    \n    for (int i = 0; i < 3; ++i) {\n        std::cout << hills[i] << std::endl;\n    }\n    \n    return 0;\n}\n\nCUDA code:\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_transpose(int *hills, int N) {\n    int idx = threadIdx.x;\n    int i = idx;\n    int j = N - 1 - idx;\n    \n    if (idx < N / 2) {\n        // swap hills[i] and hills[j]\n        int temp = hills[i];\n        hills[i] = hills[j];\n        hills[j] = temp;\n    } else {\n        // swap hills[i] and hills[j]\n        int temp = hills[i];\n        hills[i]",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    },
    {
      "id": "s003006852.cpp",
      "original_c": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    priority_queue<int> pq;\n\n    for (int i = 0; i < 10; ++i) {\n        int height;\n        cin >> height;\n        pq.emplace(height);\n    }\n\n\n    for (int i = 0; i <= 2; ++i) {\n        std::cout << pq.top() << endl;\n        pq.pop();\n    }\n\n    return 0;\n}",
      "translated_code": "#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *arr, int size) {\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n\n    if (i == 0) {\n        if (j == 0) {\n            if (k == 0) {\n                arr[i] = arr[i] + 1;\n            } else {\n                arr[i] = arr[i] - 1;\n            }\n        } else {\n            if (k == 0) {\n                arr[i] = arr[i] + 1;\n            } else {\n                arr[i] = arr[i] - 1;\n            }\n        }\n    } else {\n        if (j == 0) {\n            if (k == 0) {\n                arr[i] = arr[i] + 1;\n            } else {\n                arr[i] = arr[i] - 1;\n            }\n        } else {\n            if (k == 0) {\n                arr[i] = arr[i] + 1;\n            } else {\n                arr[i] = arr[i] - 1;\n            }\n        }\n    }\n}\n\nint main() {\n    int size = 10;\n    int *arr = (int *)malloc(size * sizeof(int));\n    cudaMalloc(&arr, size * sizeof(int));\n    cudaMemcpy(arr, input_array, size * sizeof(int), cudaMemcpyHostToDevice);\n\n    for (int i = 0; i < size; ++i) {\n        arr[i] = input_array[i];\n    }\n\n    __launch_bounds__(1, size);\n    odd_even_sort(arr, size);\n    cudaMemcpy(arr, output_array, size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    free(arr);\n    return 0;\n}\n\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    priority_queue<int> pq;\n\n    for (int i = 0; i < 10; ++i) {\n        int height;\n        cin >> height;\n        pq.emplace(height);\n    }\n\n    for (int i = 0; i <= 2; ++i) {\n        std::cout << pq.top() << endl;\n        pq.pop();\n    }\n\n    return 0;\n}\n\nCUDA code:\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *arr, int size) {\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n\n    if (i == 0) {\n        if (j == 0) {\n            if (k == 0) {\n                arr[i] = arr[i] + 1;\n            } else {\n                arr[i] = arr[i] - 1;\n            }\n        } else {\n            if (k == 0) {\n                arr[i] = arr[i] + 1;\n            } else {\n                arr[i] = arr[i] - 1;\n            }\n        }\n    } else {\n        if (j == 0) {\n            if (k == 0) {\n                arr[i] = arr[i] + 1;\n            } else {\n                arr[i] = arr[i] - 1;\n            }\n        } else {\n            if (k == 0) {\n                arr[i] = arr[i] + 1;\n            } else {\n                arr[i] = arr[i] - 1;\n            }\n        }\n    }\n}\n\nint main() {\n    int size = 10;\n    int *arr = (int *)malloc(size * sizeof(int));\n    cudaMalloc(&arr, size * sizeof(int));\n    cudaMemcpy(arr, input_array, size * sizeof(int), cudaMemcpyHostToDevice);\n\n    for (int i = 0; i < size; ++i) {\n        arr[i] = input_array[i];\n    }\n\n    __launch_bounds__(1, size);\n    odd_even_sort(arr, size);\n    cudaMemcpy(arr, output_array, size * sizeof(int), cudaMemcpyDeviceToHost);\n\n    free(arr);\n    return 0;\n}\n\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    priority_queue<int> pq;\n\n    for (int i = 0; i < 10; ++i) {\n        int height;\n        cin >> height;\n        pq.emplace(height);\n    }\n\n    for (int i = 0; i <= 2; ++i) {\n        std::cout << pq.top() << endl;\n        pq.pop();\n    }\n\n    return 0;\n}\n\nCUDA code:\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *arr, int size) {\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n\n    if (i == 0) {\n        if (j == 0) {\n            if (k ==",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    },
    {
      "id": "s004707294.cpp",
      "original_c": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n \nint main(){\n     int a[10],i,judge;\n     for(i=0;i<10;i++) cin >> a[i];\n     judge = 0;\n     do{\n       judge = 1;\n       for(i=0;i<9;i++){\n         if(a[i]<a[i+1]){\n           swap(a[i],a[i+1]);\n           judge = 0;\n         }\n       }\n     }while(!judge);\n \n     for(i=0;i<3;i++)\n       cout << a[i] << endl;\n \n   return 0;\n}",
      "translated_code": "#include <cuda_runtime.h>\n#include <stdio.h>\n \n__global__ void odd_even_sort(int *a, int N)\n{\n   int idx = threadIdx.x;\n   int offset = idx * 2;\n   int i = offset;\n   int j = offset + 1;\n   int k = offset + 2;\n   int temp;\n   if (idx == 0) {\n       temp = a[i];\n       a[i] = a[j];\n       a[j] = a[k];\n       a[k] = temp;\n   } else {\n       if (idx == 1) {\n           temp = a[i];\n           a[i] = a[j];\n           a[j] = a[k];\n           a[k] = temp;\n       } else {\n           if (idx == 2) {\n               temp = a[i];\n               a[i] = a[j];\n               a[j] = a[k];\n               a[k] = temp;\n           }\n       }\n   }\n}\n \nint main() {\n   int a[10], i;\n   cudaMalloc(&a, 10 * sizeof(int));\n   cudaMemcpy(a, a, 10 * sizeof(int), cudaMemcpyHostToDevice);\n   for (i = 0; i < 10; i++) {\n       scanf(\"%d\", &a[i]);\n   }\n   cudaFree(a);\n   return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n \n__global__ void odd_even_sort(int *a, int N)\n{\n   int idx = threadIdx.x;\n   int offset = idx * 2;\n   int i = offset;\n   int j = offset + 1;\n   int k = offset + 2;\n   int temp;\n   if (idx == 0) {\n       temp = a[i];\n       a[i] = a[j];\n       a[j] = a[k];\n       a[k] = temp;\n   } else {\n       if (idx == 1) {\n           temp = a[i];\n           a[i] = a[j];\n           a[j] = a[k];\n           a[k] = temp;\n       } else {\n           if (idx == 2) {\n               temp = a[i];\n               a[i] = a[j];\n               a[j] = a[k];\n               a[k] = temp;\n           }\n       }\n   }\n}\n \nint main() {\n   int a[10], i;\n   cudaMalloc(&a, 10 * sizeof(int));\n   cudaMemcpy(a, a, 10 * sizeof(int), cudaMemcpyHostToDevice);\n   for (i = 0; i < 10; i++) {\n       scanf(\"%d\", &a[i]);\n   }\n   cudaFree(a);\n   return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n \n__global__ void odd_even_sort(int *a, int N)\n{\n   int idx = threadIdx.x;\n   int offset = idx * 2;\n   int i = offset;\n   int j = offset + 1;\n   int k = offset + 2;\n   int temp;\n   if (idx == 0) {\n       temp = a[i];\n       a[i] = a[j];\n       a[j] = a[k];\n       a[k] = temp;\n   } else {\n       if (idx == 1) {\n           temp = a[i];\n           a[i] = a[j];\n           a[j] = a[k];\n           a[k] = temp;\n       } else {\n           if (idx == 2) {\n               temp = a[i];\n               a[i] = a[j];\n               a[j] = a[k];\n               a[k] = temp;\n           }\n       }\n   }\n}\n \nint main() {\n   int a[10], i;\n   cudaMalloc(&a, 10 * sizeof(int));\n   cudaMemcpy(a, a, 10 * sizeof(int), cudaMemcpyHostToDevice);\n   for (i = 0; i < 10; i++) {\n       scanf(\"%d\", &a[i]);\n   }\n   cudaFree(a);\n   return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n \n__global__ void odd_even_sort(int *a, int N)\n{\n   int idx = threadIdx.x;\n   int offset = idx * 2;\n   int i = offset;\n   int j = offset + 1;\n   int k = offset + 2;\n   int temp;\n   if (idx == 0) {\n       temp = a[i];\n       a[i] = a[j];\n       a[j] = a[k];\n       a[k] = temp;\n   } else {\n       if (idx == 1) {\n           temp = a[i];\n           a[i] = a[j];\n           a[j] = a[k];\n           a[k] = temp;\n       } else {\n           if (idx == 2) {\n               temp = a[i];\n               a[i]",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    },
    {
      "id": "s010845670.cpp",
      "original_c": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n  vector<int> h(10);\n  for(int i=0;i<10;++i)\n\tcin >> h[i];\n  sort(h.begin(), h.end());\n  for(int i=0;i<3;++i)\n\tcout << h[9-i] << endl;\n  return 0;\n}",
      "translated_code": "#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *h, int N){\n  int i = threadIdx.x;\n  int j = threadIdx.y;\n  int k = threadIdx.z;\n  int offset = (i + j + k) % 2;\n  if (offset == 0) {\n    for (int m = 0; m < N; m += 2) {\n      h[m] = h[m + 1];\n    }\n  } else {\n    for (int m = 1; m < N; m += 2) {\n      h[m] = h[m - 1];\n    }\n  }\n}\n\nint main() {\n  int N = 10;\n  int *h = (int*)cudaMalloc(&N, sizeof(int));\n  cudaMemcpy(h, h, N, cudaMemcpyHostToDevice);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &h[i]);\n  }\n  cudaMemcpy(h, h, N, cudaMemcpyDeviceToHost);\n  cudaFree(h);\n  return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *h, int N) {\n  int i = threadIdx.x;\n  int j = threadIdx.y;\n  int k = threadIdx.z;\n  int offset = (i + j + k) % 2;\n  if (offset == 0) {\n    for (int m = 0; m < N; m += 2) {\n      h[m] = h[m + 1];\n    }\n  } else {\n    for (int m = 1; m < N; m += 2) {\n      h[m] = h[m - 1];\n    }\n  }\n}\n\nint main() {\n  int N = 10;\n  int *h = (int*)cudaMalloc(&N, sizeof(int));\n  cudaMemcpy(h, h, N, cudaMemcpyHostToDevice);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &h[i]);\n  }\n  cudaMemcpy(h, h, N, cudaMemcpyDeviceToHost);\n  cudaFree(h);\n  return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *h, int N) {\n  int i = threadIdx.x;\n  int j = threadIdx.y;\n  int k = threadIdx.z;\n  int offset = (i + j + k) % 2;\n  if (offset == 0) {\n    for (int m = 0; m < N; m += 2) {\n      h[m] = h[m + 1];\n    }\n  } else {\n    for (int m = 1; m < N; m += 2) {\n      h[m] = h[m - 1];\n    }\n  }\n}\n\nint main() {\n  int N = 10;\n  int *h = (int*)cudaMalloc(&N, sizeof(int));\n  cudaMemcpy(h, h, N, cudaMemcpyHostToDevice);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &h[i]);\n  }\n  cudaMemcpy(h, h, N, cudaMemcpyDeviceToHost);\n  cudaFree(h);\n  return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *h, int N) {\n  int i = threadIdx.x;\n  int j = threadIdx.y;\n  int k = threadIdx.z;\n  int offset = (i + j + k) % 2;\n  if (offset == 0) {\n    for (int m = 0; m < N; m += 2) {\n      h[m] = h[m + 1];\n    }\n  } else {\n    for (int m = 1; m < N; m += 2) {\n      h[m] = h[m - 1];\n    }\n  }\n}\n\nint main() {\n  int N = 10;\n  int *h = (int*)cudaMalloc(&N, sizeof(int));\n  cudaMemcpy(h, h, N, cudaMemcpyHostToDevice);\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d\", &h[i]);\n  }\n  cudaMemcpy(h, h, N, cudaMemcpyDeviceToHost);\n  cudaFree(h);\n  return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n\n__global__ void odd_even_sort(int *h, int N) {\n  int i = threadIdx.x;\n  int j = threadIdx.y;\n  int k = threadIdx.z;\n  int offset = (i + j + k) % 2;\n  if (offset == 0) {\n    for (int m = 0; m < N; m += 2) {\n      h",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    },
    {
      "id": "s022801097.cpp",
      "original_c": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \nint main(){\n    int i;\n    int list[10];\n    for(i=0;i<10;i++){\n        cin >> list[i];\n    }\n    sort(list,list+10);\n    for(i=0;i<3;i++){\n        cout << list[9-i] << endl;\n    }\n    return 0;\n}",
      "translated_code": "#include <cuda_runtime.h>\n#include <stdio.h>\n \n__global__ void odd_even_sort(int *array, int size){\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n    int offset = (i + j + k) % 2;\n    if (offset == 0) {\n        for (int m = size - 1; m > 0; m--) {\n            if (array[m] > array[m - 1]) {\n                array[m] = array[m - 1];\n                array[m - 1] = array[m];\n            }\n        }\n    } else {\n        for (int m = size - 1; m > 0; m--) {\n            if (array[m] < array[m - 1]) {\n                array[m] = array[m - 1];\n                array[m - 1] = array[m];\n            }\n        }\n    }\n}\n \nint main() {\n    int N = 10;\n    int *array = (int *)malloc(N * sizeof(int));\n    cudaMalloc(&array, N * sizeof(int));\n    cudaMemcpy(array, list, N * sizeof(int), cudaMemcpyHostToDevice);\n    for (int i = 0; i < N; i++) {\n        __syncthreads();\n        if (i % 2 == 0) {\n            odd_even_sort(array, N);\n        }\n    }\n    cudaFree(array);\n    return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n \n__global__ void odd_even_sort(int *array, int size) {\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n    int offset = (i + j + k) % 2;\n    if (offset == 0) {\n        for (int m = size - 1; m > 0; m--) {\n            if (array[m] > array[m - 1]) {\n                array[m] = array[m - 1];\n                array[m - 1] = array[m];\n            }\n        }\n    } else {\n        for (int m = size - 1; m > 0; m--) {\n            if (array[m] < array[m - 1]) {\n                array[m] = array[m - 1];\n                array[m - 1] = array[m];\n            }\n        }\n    }\n}\n \nint main() {\n    int N = 10;\n    int *array = (int *)malloc(N * sizeof(int));\n    cudaMalloc(&array, N * sizeof(int));\n    cudaMemcpy(array, list, N * sizeof(int), cudaMemcpyHostToDevice);\n    for (int i = 0; i < N; i++) {\n        __syncthreads();\n        if (i % 2 == 0) {\n            odd_even_sort(array, N);\n        }\n    }\n    cudaFree(array);\n    return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n \n__global__ void odd_even_sort(int *array, int size) {\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n    int offset = (i + j + k) % 2;\n    if (offset == 0) {\n        for (int m = size - 1; m > 0; m--) {\n            if (array[m] > array[m - 1]) {\n                array[m] = array[m - 1];\n                array[m - 1] = array[m];\n            }\n        }\n    } else {\n        for (int m = size - 1; m > 0; m--) {\n            if (array[m] < array[m - 1]) {\n                array[m] = array[m - 1];\n                array[m - 1] = array[m];\n            }\n        }\n    }\n}\n \nint main() {\n    int N = 10;\n    int *array = (int *)malloc(N * sizeof(int));\n    cudaMalloc(&array, N * sizeof(int));\n    cudaMemcpy(array, list, N * sizeof(int), cudaMemcpyHostToDevice);\n    for (int i = 0; i < N; i++) {\n        __syncthreads();\n        if (i % 2 == 0) {\n            odd_even_sort(array, N);\n        }\n    }\n    cudaFree(array);\n    return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n \n__global__ void odd_even_sort(int *array, int size) {\n    int i = threadIdx.x;\n    int j = threadIdx.y;\n    int k = threadIdx.z;\n    int offset = (i + j + k) % 2;\n    if (offset == 0) {\n        for (int m = size - 1; m > 0; m--) {\n            if (array[m] > array[m - 1",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    },
    {
      "id": "s024128016.cpp",
      "original_c": "#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  vector<int> a;\n  a.resize(10);\n  for(int i=0;i<10;i++){\n    cin>>a[i];\n  }\n  sort(a.begin(),a.end());\n  cout<<a[9]<<endl<<a[8]<<endl<<a[7]<<endl;\n}",
      "translated_code": "#include <cuda_runtime.h>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n__global__ void odd_even_transpose(int *a, int N){\n  int i = threadIdx.x;\n  int j = threadIdx.y;\n  int k = threadIdx.z;\n  int idx = i + j * N + k * N;\n  if (idx < N) {\n    a[idx] = a[idx + 1];\n  }\n  if (idx + 1 < N) {\n    a[idx + 1] = a[idx];\n  }\n}\n\nint main() {\n  int N = 10;\n  cudaMalloc(&a, N * sizeof(int));\n  cudaMemcpy(a, a, N * sizeof(int), cudaMemcpyHostToDevice);\n  for (int i = 0; i < N; i++) {\n    int idx = i + 0 * N + 0 * N;\n    if (idx < N) {\n      a[idx] = a[idx + 1];\n    }\n    if (idx + 1 < N) {\n      a[idx + 1] = a[idx];\n    }\n  }\n  cudaMemcpy(a, a, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaFree(a);\n  return 0;\n}\n\nBut the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is not working. The output is not correct. What is the problem?\n\nThe problem is that the code is",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    },
    {
      "id": "s934624544.cpp",
      "original_c": "#include<iostream>\n#define MAX 9\nusing namespace std;\nint main(){\n  int i = 1, j = 1;\n  int sum;\n  for( i = 1 ; i <= MAX ; i++ ){\n    for(j = 1 ; j <= MAX ; j++ ){\n      sum = i * j;\n      cout << i << \"x\" << j << \"=\" << sum << endl;\n    }\n  }\n  return 0;\n}",
      "translated_code": "#include <cuda_runtime.h>\n#include <stdio.h>\n__global__ void odd_even_transpose(int *a, int *b, int N){\n  int i = threadIdx.x;\n  int j = threadIdx.y;\n  int k = threadIdx.z;\n  int idx = i + j * N + k * N;\n  if (idx < N) {\n    a[idx] = b[idx];\n  } else {\n    a[idx] = a[idx - N];\n  }\n}\n\nint main() {\n  int N = 9;\n  int *a = (int*)malloc(N * sizeof(int));\n  int *b = (int*)malloc(N * sizeof(int));\n  cudaMalloc(&a, N * sizeof(int));\n  cudaMalloc(&b, N * sizeof(int));\n  cudaMemcpy(a, &i, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaMemcpy(b, &j, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaMemcpy(a, &sum, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaFree(a);\n  cudaFree(b);\n  return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n__global__ void odd_even_transpose(int *a, int *b, int N){\n  int i = threadIdx.x;\n  int j = threadIdx.y;\n  int k = threadIdx.z;\n  int idx = i + j * N + k * N;\n  if (idx < N) {\n    a[idx] = b[idx];\n  } else {\n    a[idx] = a[idx - N];\n  }\n}\n\nint main() {\n  int N = 9;\n  int *a = (int*)malloc(N * sizeof(int));\n  int *b = (int*)malloc(N * sizeof(int));\n  cudaMalloc(&a, N * sizeof(int));\n  cudaMalloc(&b, N * sizeof(int));\n  cudaMemcpy(a, &i, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaMemcpy(b, &j, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaMemcpy(a, &sum, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaFree(a);\n  cudaFree(b);\n  return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n__global__ void odd_even_transpose(int *a, int *b, int N){\n  int i = threadIdx.x;\n  int j = threadIdx.y;\n  int k = threadIdx.z;\n  int idx = i + j * N + k * N;\n  if (idx < N) {\n    a[idx] = b[idx];\n  } else {\n    a[idx] = a[idx - N];\n  }\n}\n\nint main() {\n  int N = 9;\n  int *a = (int*)malloc(N * sizeof(int));\n  int *b = (int*)malloc(N * sizeof(int));\n  cudaMalloc(&a, N * sizeof(int));\n  cudaMalloc(&b, N * sizeof(int));\n  cudaMemcpy(a, &i, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaMemcpy(b, &j, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaMemcpy(a, &sum, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaFree(a);\n  cudaFree(b);\n  return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n__global__ void odd_even_transpose(int *a, int *b, int N){\n  int i = threadIdx.x;\n  int j = threadIdx.y;\n  int k = threadIdx.z;\n  int idx = i + j * N + k * N;\n  if (idx < N) {\n    a[idx] = b[idx];\n  } else {\n    a[idx] = a[idx - N];\n  }\n}\n\nint main() {\n  int N = 9;\n  int *a = (int*)malloc(N * sizeof(int));\n  int *b = (int*)malloc(N * sizeof(int));\n  cudaMalloc(&a, N * sizeof(int));\n  cudaMalloc(&b, N * sizeof(int));\n  cudaMemcpy(a, &i, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaMemcpy(b, &j, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaMemcpy(a, &sum, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaFree(a);\n  cudaFree(b);\n  return 0;\n}\n\n#include <cuda_runtime.h>\n#include <stdio.h>\n__global__ void odd_even_transpose(int *a, int *b, int N){\n  int i = threadIdx.x;\n  int j = threadIdx.y;\n  int k = threadIdx.z;\n  int idx = i + j * N + k * N;\n  if (idx < N) {\n    a[idx] = b[idx];\n  } else {\n    a[idx] = a[idx - N];\n  }\n}\n\nint main() {\n  int N = 9;\n  int *a = (int*)malloc(N * sizeof(int));\n  int *b = (int*)",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    },
    {
      "id": "s936772539.cpp",
      "original_c": "#include <iostream>\nusing namespace std;\nint main() {\n  int a,b;\n  for(int j=1;j<=9;j++){\n  for(int i=1;i<=9;i++)\n    cout<<j<<'x'<<i<<'='<<j*i<<endl;\n  }  \n}",
      "translated_code": "#include <cuda_runtime.h>\n#include <stdio.h>\n__global__ void odd_even_transpose(int *a, int *b, int N) {\n  int i,j;\n  __syncthreads();\n  for (i=0; i < N; i++) {\n    for (j=0; j < N; j++) {\n      if (i == j) {\n        b[i] = a[j];\n      } else {\n        b[i] = a[j];\n      }\n    }\n  }\n}\n__global__ void bubble_sort(int *a, int *b, int N) {\n  int i,j;\n  __syncthreads();\n  for (i=0; i < N; i++) {\n    for (j=0; j < N; j++) {\n      if (a[i] > a[j]) {\n        b[i] = a[j];\n        a[j] = a[i];\n      }\n    }\n  }\n}\n__global__ void transpose(int *a, int *b, int N) {\n  int i,j;\n  __syncthreads();\n  for (i=0; i < N; i++) {\n    for (j=0; j < N; j++) {\n      if (i == j) {\n        b[i] = a[j];\n      } else {\n        b[i] = a[j];\n      }\n    }\n  }\n}\n__global__ void swap(int *a, int *b, int i, int j) {\n  int k;\n  __syncthreads();\n  for (k=0; k < N; k++) {\n    if (k == i) {\n      a[k] = b[k];\n    } else if (k == j) {\n      b[k] = a[k];\n    }\n  }\n}\n__global__ void swap2(int *a, int *b, int i, int j) {\n  int k;\n  __syncthreads();\n  for (k=0; k < N; k++) {\n    if (k == i) {\n      a[k] = b[k];\n    } else if (k == j) {\n      b[k] = a[k];\n    }\n  }\n}\n__global__ void swap3(int *a, int *b, int i, int j) {\n  int k;\n  __syncthreads();\n  for (k=0; k < N; k++) {\n    if (k == i) {\n      a[k] = b[k];\n    } else if (k == j) {\n      b[k] = a[k];\n    }\n  }\n}\n\nint main() {\n  int a,b;\n  for(int j=1;j<=9;j++){\n    for(int i=1;i<=9;i++)\n      scanf(\"%d\",&a);\n  }\n  cudaMalloc(&a, N * sizeof(int));\n  cudaMalloc(&b, N * sizeof(int));\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyHostToDevice);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(b, input, N * sizeof(int), cudaMemcpyDeviceToHost);\n  cudaMemcpy(a, input, N * sizeof",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    },
    {
      "id": "s937249506.cpp",
      "original_c": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nint main(){\n    for(int i=1;i<=9;i++){\n        for(int j=1;j<=9;j++){\n            cout<<i<<\"x\"<<j<<\"=\"<<i*j<<endl;\n        }\n    }\n}",
      "translated_code": "",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    },
    {
      "id": "s940954942.cpp",
      "original_c": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double pi = 3.14159265358979323846;\nconst int mod = 1000000007;\n\nint main(){\n  for(int i=1; i<=9; i++){\n    for(int j=1; j<=9; j++){\n      cout << i << \"x\" << j << \"=\" << i*j << endl;\n    }\n  }\n\n  return 0;\n}",
      "translated_code": "",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    },
    {
      "id": "s941439692.cpp",
      "original_c": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nint main(void){\n  FOR(a,1,10)\n    FOR(b,1,10)\n      printf(\"%dx%d=%d\\n\",a,b,a*b);\n  return 0;\n}",
      "translated_code": "",
      "compile_success": false,
      "run_success": false,
      "compile_stderr": "Compilation skipped on macOS",
      "run_stderr": "Execution skipped on macOS"
    }
  ]
}